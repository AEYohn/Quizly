"""
Knowledge Graph Engine — DAG-based prerequisite enforcement.

Uses the syllabus tree (already generated by syllabus_service) to build a
directed acyclic graph of concept prerequisites, then exposes methods for:
  - Checking which concepts are "ready" (all prereqs mastered)
  - Finding the optimal study path (topological sort of unmastered concepts)
  - Identifying concepts that are close to being unlocked
"""

from typing import Any, Dict, List, Optional


MASTERY_THRESHOLD = 0.5  # P(L) at which a prereq is considered "met"


class KnowledgeGraph:
    """DAG built from a syllabus tree JSON."""

    def __init__(self, syllabus_tree: Dict[str, Any]):
        # concept_id → list of prerequisite concept_ids
        self.graph: Dict[str, List[str]] = {}
        # concept_id → dict with name, concepts, etc.
        self.topic_meta: Dict[str, Dict[str, Any]] = {}

        for unit in syllabus_tree.get("units", []):
            for topic in unit.get("topics", []):
                tid = topic["id"]
                self.graph[tid] = topic.get("prerequisites", [])
                self.topic_meta[tid] = topic

    def get_ready_concepts(
        self, mastery_states: Dict[str, float]
    ) -> List[str]:
        """Return concepts where ALL prerequisites have mastery >= threshold."""
        ready = []
        for concept, prereqs in self.graph.items():
            if all(
                mastery_states.get(p, 0) >= MASTERY_THRESHOLD
                for p in prereqs
            ):
                ready.append(concept)
        return ready

    def get_optimal_path(
        self, current_mastery: Dict[str, float]
    ) -> List[str]:
        """
        Topological sort filtered to unmastered concepts.

        Returns an ordered list: study these concepts in this order.
        """
        unmastered = {
            c for c in self.graph
            if current_mastery.get(c, 0) < MASTERY_THRESHOLD
        }

        if not unmastered:
            return []

        # Kahn's algorithm on the subgraph of unmastered concepts
        in_degree: Dict[str, int] = {c: 0 for c in unmastered}
        adj: Dict[str, List[str]] = {c: [] for c in unmastered}

        for concept in unmastered:
            for prereq in self.graph.get(concept, []):
                if prereq in unmastered:
                    adj[prereq].append(concept)
                    in_degree[concept] = in_degree.get(concept, 0) + 1

        queue = sorted(
            [c for c in unmastered if in_degree.get(c, 0) == 0]
        )
        result = []

        while queue:
            node = queue.pop(0)
            result.append(node)
            for neighbor in adj.get(node, []):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
            queue.sort()

        return result

    def get_unlockable(
        self, mastery_states: Dict[str, float]
    ) -> List[str]:
        """
        Concepts that would unlock if their single remaining prereq is mastered.

        Useful for highlighting "almost unlocked" nodes on the tree.
        """
        unlockable = []
        for concept, prereqs in self.graph.items():
            if not prereqs:
                continue
            unmet = [
                p for p in prereqs
                if mastery_states.get(p, 0) < MASTERY_THRESHOLD
            ]
            if len(unmet) == 1:
                unlockable.append(concept)
        return unlockable

    def get_recommended_next(
        self, mastery_states: Dict[str, float]
    ) -> Optional[str]:
        """
        Single best concept to study next.

        Strategy: first unmastered concept in optimal path that is ready.
        """
        path = self.get_optimal_path(mastery_states)
        ready = set(self.get_ready_concepts(mastery_states))

        for concept in path:
            if concept in ready:
                return concept
        return path[0] if path else None
